<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ibard</title>
  
  <subtitle>乐观， 进取</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.ibard.cn/"/>
  <updated>2018-10-05T11:37:17.886Z</updated>
  <id>https://blog.ibard.cn/</id>
  
  <author>
    <name>Ming Chow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>List接口的实现类</title>
    <link href="https://blog.ibard.cn/2018/09/List%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"/>
    <id>https://blog.ibard.cn/2018/09/List有序集合/</id>
    <published>2018-09-01T00:00:00.000Z</published>
    <updated>2018-10-05T11:37:17.886Z</updated>
    
    <content type="html"><![CDATA[<p>List表示有序的集合（元素可以重复），根据索引来寻找元素，放入其中的元素的存储顺序和放入顺序是一致的。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/al-1.png-zoom50" alt="al-1"></p><p>0.继承自AbstractList，拥有通用的方法如Iterator迭代器。实现List接口。</p><p>1.底层是<code>transient Object[] elementData</code> 数组。可以看到默认大小是10。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/al-2.png-zoom50" alt="al-2"></p><p>2.不同的初始化方式，有一点区别。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/al-3.png-zoom50" alt="al-3"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未指定,默认是10。构造的数组大小为0，要等到放入第一个元素时才会扩容成10个。</span></span><br><span class="line">List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造的数组大小为0。</span></span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造的数组大小为14</span></span><br><span class="line">List&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">14</span>);</span><br></pre></td></tr></table></figure><p>3.数组扩容</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/al-4.png-zoom50" alt="al-4"></p><p>默认初始化的内部数组大小是10，当放入第11个元素时会进行第一次扩容:<code>newCapacity = oldCapacity + oldCapacity &gt;&gt; 1</code> ，也就是变成原来的1.5倍。（所以默认情况下，放入第11个元素时，扩容成15个；放入第16个元素时，扩容成22个；放入第23个元素时，扩容成33个。）</p><p>数组扩容的操作是进行数组的复制，所以扩容消耗资源，应该尽量先指明所需的容量，来减少扩容操作。对于已经存在的ArrayList，在放入大量元素前，可以手动进行扩容：<code>ArrayList.ensureCapacity(capacity)</code> 来指定内部数组的大小。</p><p>4.有一个骚操作，把ArrayList转化成对象数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用toArray方法,传入对象数组接收,返回Object[]数组</span></span><br><span class="line">Object[] objects2 = appleList.toArray(<span class="keyword">new</span> Apple[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line">Apple[] apples3 = (Apple[]) objects2;</span><br></pre></td></tr></table></figure><p>5.ArrayList的<code>add(int index, Object obj)</code>和<code>remove(int index) / remove(Object obj)</code>都会进行数组的复制，所以ArrayList适合随机访问<code>get(int index)</code>，不适合随机增加、删除操作多的场景。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/al-5.png-zoom50" alt="al-5"></p><h3 id="ArrayList总结"><a href="#ArrayList总结" class="headerlink" title="ArrayList总结"></a>ArrayList总结</h3><p>1.初始化时应该指明容量，避免多次的扩容操作。</p><p>2.使用场景应该是随机查找比较多而随机增加、删除操作比较少的场景。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/al-6.png-zoom50" alt="al-6"></p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/al-1.png-zoom50" alt="al-7"></p><p>1.继承自AbstractSequentialList，拥有通用的方法如iterator。实现List接口。实现Queue接口，拥有队列的特性；实现Deque接口，拥有双端队列的特性。</p><p>2.LinkedList内部的节点。拥有前后指针，实现的是双端队列的性质。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/ll-2.png-zoom50" alt="ll-2"></p><p>内部的私有属性，存储了链表的节点个数以及保存了链表的头尾指针。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/ll-3.png-zoom50" alt="ll-3"></p><p>3.因为LinkedList实现了Queue接口、Deque接口，所以它既能作为队列也能作为堆栈来使用。又因为实现了List接口，所以又是有序的Collection。这意味着它有3种数据结构的作用，我们应该在正确的场景下正确语义化使用，这表示我们要使用合适的接口来声明LinedList。(<strong>因为双端队列Deque接口提供了传统Stack的操作方法声明，所以它实际上是4种数据结构</strong>)</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/ll-4.png-zoom50" alt="ll-4"></p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/ll-5.png-zoom50" alt="ll-5"></p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/ll-6.png-zoom50" alt="ll-6"></p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/ll-7.png-zoom50" alt="ll-7"></p><p>4.对于LinkedList的随机访问操作，它内部有一个优化。如果index&lt;(size/2)，就从头部开始查找；否则从尾部开始查找。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/ll-8.png-zoom75" alt="ll-8"></p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/ll-9.png-zoom50" alt="ll-9"></p><h3 id="LinkedList总结"><a href="#LinkedList总结" class="headerlink" title="LinkedList总结"></a>LinkedList总结</h3><p>1.使用场景应该是增加、删除操作多的情况，而随机访问操作少的情况。</p><p>2.LinkedList有3种数据结构的身份，我们应该在正确的场景下进行正确的接口声明，并且使用与之对应的语义化方法来操作LinkedList。</p><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>vector作为古老的集合类，是jdk1.2之后才改为实现List接口的。它与ArrayList的性质很像（2者的继承图是一样的），但是其内部方法都使用了synchronized修饰来保证线程安全，这使得对Vector的操作在多线程下变成了串行操作。<strong>Vector已经不推荐使用了，单线程下我们选用ArrayList，多线程下我们选用CopyOnWriteArray。</strong></p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/vl-1.png-zoom50" alt="vl-1"></p><p>1.默认初始化大小为10，扩容操作时，如果构造时指明了增大的容量，则增加；否则默认变成原来的2倍。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/vl-2.png-zoom50" alt="vl-2"></p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/vl-3.png-zoom50" alt="vl-3"></p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack作为Vector的子类，可用于实现堆栈。但是不建议使用，而是使用LinkedList来替代堆栈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;List表示有序的集合（元素可以重复），根据索引来寻找元素，放入其中的元素的存储顺序和放入顺序是一致的。&lt;/p&gt;
&lt;h2 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="List接口" scheme="https://blog.ibard.cn/tags/List%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>动态代理</title>
    <link href="https://blog.ibard.cn/2018/09/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://blog.ibard.cn/2018/09/动态代理/</id>
    <published>2018-09-01T00:00:00.000Z</published>
    <updated>2018-10-05T11:37:29.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、先谈静态代理"><a href="#1、先谈静态代理" class="headerlink" title="1、先谈静态代理"></a>1、先谈静态代理</h2><p>对于静态代理，我们已经很熟悉了。我们拥有一个抽象类，真实类继承自抽象类并重写其业务方法，代理类持有真实类的对象实例，在重写业务方法中通过调用真实类的方法，并且添加自己的逻辑。这样代理类就实现了对真实类的行为代理。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/sp-1.png-zoom50" alt="sp-1"></p><p>静态代理的缺点在于，我们需要实现多个代理类，这无疑是很崩溃的。</p><h2 id="2、JDK动态代理"><a href="#2、JDK动态代理" class="headerlink" title="2、JDK动态代理"></a>2、JDK动态代理</h2><blockquote><p>优点先行：我们说静态代理的缺点在于需要为每一个真实类都生成一个对应的代理类，这样就很繁琐。动态代理呢，我们是动态生成目标类的动态代理类，根本不需要为每一个只需要定义一个动态代理类，就可以代理所有、无数的真实类；当然我们需要一个类来实现<code>InvocationHandler</code>接口即可。也就是说我们只需要一个类即可。</p></blockquote><p>java中提供了一个接口<code>InvocationHandler</code>和<code>Proxy</code>类来实现动态代理。</p><p><code>InvocationHandler</code>接口是代理实例用来调用处理程序（代理行为）的接口，它只有一个方法。接收的参数为：动态代理对象，代理对象调用的接口方法的实例，执行参数。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/dp-1.png-zoom75" alt="dp-1"></p><p>就如下面的<code>Market</code>类实现了<code>InvocationHandler</code>接口，内部的<code>Object target</code>用来持有动态代理的真实对象实例，<code>bind</code>方法用来接收外部真实类对象传递给<code>target</code>。然后重点就是重写<code>invoke</code>方法了，这个方法和下面的<code>Proxy</code>类一起讲解。</p><blockquote><p>这个类是用来处理动态代理的逻辑的，它的作用是接收生成的动态代理对象和被代理对象实现的接口与运行时的参数，这样就能拦截对接口方法的调用，从而实现自己的拦截逻辑。</p></blockquote><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/dp-2.png-zoom50" alt="dp-2"></p><p>如下图，我们在测试类中，使用<code>Proxy</code>类的<code>newProxyInstance</code>静态方法来生成动态代理对象。该方法很重要，传入的参数：被代理类的类加载器，被代理类的所实现的接口(用数组保存的)，实现了<code>InvocationHandler</code>的接口的动态代理处理类。</p><blockquote><p>这个类用来生成了动态代理的对象，很神奇的是，我们调用接口的方法时，就发现方法被拦截了，这时候生成的是动态代理对象，所以接口方法的逻辑已经是被拦截的逻辑了。（这里我们看成是一个新的动态代理的对象就好了）</p></blockquote><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/dp-3.png" alt="dp-3"></p><p>为避免混乱，将包、类的结构给出：</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/dp-4.png-zoom75" alt="dp-4"></p><p>动态代理类的命名规则：包名+<code>$Proxy</code>+id，同一个接口的实现类的id是相同的。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/dp-5.png-zoom75" alt="dp-5"></p><h4 id="JDK动态代理的总结（不足）"><a href="#JDK动态代理的总结（不足）" class="headerlink" title="JDK动态代理的总结（不足）"></a>JDK动态代理的总结（不足）</h4><p>1.JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法。因此，对一个类而言，如果想要对它使用JDK动态代理，那么这个类就必须实现接口<code>interface</code>，并且我们拦截的是其接口声明的方法才行。简言之，<strong>JDK动态代理只能对实现了接口的类生成代理，而不能针对未实现接口的类</strong>。</p><p>2.我们发现，在JDK动态代理的实现过程中，我们无法对接口中的各个方法都实现一段独有的逻辑（如果被代理类实现的接口有多个方法，我们的动态代理的拦截逻辑却只有一段，所有的方法被拦截时都是用相同的逻辑来处理）。<strong>这是一个很大的问题。</strong></p><p>3.JDK动态代理生成的动态代理类，是无法调用原业务类自己拥有的方法的（即接口中没有声明的方法）。要明白，动态代理类的存在意义是为了拦截方法并修改逻辑；而JDK动态代理的局限性之一就是只能拦截接口所声明的方法。</p><p>4.<strong>JDK动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用<code>InvokeHandler</code>来处理。</strong></p><h2 id="3、CGLib动态代理"><a href="#3、CGLib动态代理" class="headerlink" title="3、CGLib动态代理"></a>3、CGLib动态代理</h2><p>和JDK动态代理不同的是，CGLib动态代理解决了JDK动态代理的第一个不足。也就是说，如果一个类没有实现接口，那么我们还可以使用CGLib来生成其动态代理对象。</p><p>这里我们要讲到<code>MethodInterceptor</code>接口了。注意，CGLib动态代理并不是JDK中的类，它是外部的lib包。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/dp-6.png-zoom75" alt="dp-6"></p><p>我们还需要结合动态代理对象的生成来讲解。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/dp-7.png-zoom50" alt="dp-7"></p><p>同样，我们只需要定义一个动态代理的处理类即可。实现了<code>MethodInterceptor</code>接口的类，需要重写<code>intercept</code>方法，用来拦截被代理类的方法调用。然后在该类中定义一个生产动态代理对象的方法，该方法接收被代理类的对象，然后拦截方法，设置调用拦截方法的逻辑，最后返回创建的动态代理对象。</p><h4 id="CGLib动态代理的总结"><a href="#CGLib动态代理的总结" class="headerlink" title="CGLib动态代理的总结"></a>CGLib动态代理的总结</h4><p>1.CGlib动态代理的原理是通过继承业务类，<strong>生成的动态代理类是业务类的子类</strong>，通过重写业务方法进行代理。 因为动态代理类是继承自业务类，所以该类和方法不能声明成final（无法继承或重写）。 </p><p>2.同JDK动态代理一样，CGLib动态代理也无法做到对业务类的每个方法都实现不同的拦截逻辑。</p><h2 id="JDK动态代理和CGLib动态代理的比较"><a href="#JDK动态代理和CGLib动态代理的比较" class="headerlink" title="JDK动态代理和CGLib动态代理的比较"></a>JDK动态代理和CGLib动态代理的比较</h2><p>1.JDK动态代理是面向接口，在创建代理实现类时比CGLib要快，创建动态代理类的速度快。</p><p>2.CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么会失败），在创建代理这一块没有JDK动态代理快，但是运行速度比JDK动态代理要快。</p><p>3.2者最终都是生成了一个新的动态代理类对象。</p><h2 id="Spring中的动态代理"><a href="#Spring中的动态代理" class="headerlink" title="Spring中的动态代理"></a>Spring中的动态代理</h2><h3 id="1、Spring在选择用JDK还是CGLiB的依据"><a href="#1、Spring在选择用JDK还是CGLiB的依据" class="headerlink" title="1、Spring在选择用JDK还是CGLiB的依据?"></a>1、Spring在选择用JDK还是CGLiB的依据?</h3><p>（1）当Bean实现接口时，Spring就会用JDK的动态代理。</p><p>（2）当Bean没有实现接口时，Spring使用CGlib实现。</p><p>（3）可以强制使用CGlib（在spring配置中加入<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code>）</p><h3 id="2、CGlib比JDK快？"><a href="#2、CGlib比JDK快？" class="headerlink" title="2、CGlib比JDK快？"></a>2、CGlib比JDK快？</h3><p>（1）在对JDK动态代理与CGlib动态代理的代码实验中看，1W次执行下，JDK7及8的动态代理性能比CGlib要好20%左右。</p><p>（2）使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、先谈静态代理&quot;&gt;&lt;a href=&quot;#1、先谈静态代理&quot; class=&quot;headerlink&quot; title=&quot;1、先谈静态代理&quot;&gt;&lt;/a&gt;1、先谈静态代理&lt;/h2&gt;&lt;p&gt;对于静态代理，我们已经很熟悉了。我们拥有一个抽象类，真实类继承自抽象类并重写其业务方法，代理
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>序列化</title>
    <link href="https://blog.ibard.cn/2018/09/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://blog.ibard.cn/2018/09/序列化/</id>
    <published>2018-09-01T00:00:00.000Z</published>
    <updated>2018-10-05T11:37:33.069Z</updated>
    
    <content type="html"><![CDATA[<p><strong>作用</strong> </p><p>1.当2个进程在进行远程通信时，相互发送数据，数据都是以二进制的形式传送的。如果我们要传输对象的话，就需要把对象转化为字节数组（二进制数据），接收方接收后反序列成对象。<strong>目的在于，传送对象的状态，也就是属性值</strong></p><p>2.反序列化后的对象还可以保存到硬盘上。</p><p><strong>实现方式</strong></p><p>1.实现<code>Serializable</code>接口。</p><p>2.实现<code>Serializable</code>接口，并增加<code>void writeObject(ObjectOutputStream out) throws IOException</code>与<code>void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException</code>这2个方法来自定义某些属性的序列化。</p><p>3.实现<code>Externalizable</code>接口（该接口继承自<code>Serializable</code>接口），并重写<code>writeExtername</code>与<code>readExternal</code>方法来完全自定义要序列化的属性。</p><p><strong>显式定义<code>serialVersionUID</code>属性的作用</strong></p><p>1.对于一个要进行序列化的类，我们希望类的不同版本对序列化兼容（这个类可能前前后后对字段进行删改），如果不显式设置id，这个类的每个版本的id（由系统生成）都是不一样的。那么反序列化的时候，永远只能反序列化最新的实例了（旧的实例因为id不一致将失败）。</p><p>2.所以要保证兼容的话，就需要设置一个显式的id。那么在序列化旧的实例时，新添加的或更改的字段会被设置为null，删除的字段不设置。</p><p>3.如果我们不想兼容不同版本，我们还可以为不同的版本再设置一个<strong>版本号</strong>。在序列化和反序列化的过程中（自定义序列化），我们还可以根据版本号来选择性的序列化那些变化的属性的状态。</p><p><strong>在springmvc里，javabean都要实现<code>Serializable</code>接口，并生成显式id</strong></p><p>其目的就是我们上面分析的序列化的作用以及显式id的作用，特别是在远程服务调用的项目中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;1.当2个进程在进行远程通信时，相互发送数据，数据都是以二进制的形式传送的。如果我们要传输对象的话，就需要把对象转化为字节数组（二进制数据），接收方接收后反序列成对象。&lt;strong&gt;目的在于，传送对象的状态，也就是属
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="https://blog.ibard.cn/2018/09/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://blog.ibard.cn/2018/09/二叉树/</id>
    <published>2018-09-01T00:00:00.000Z</published>
    <updated>2018-10-05T11:37:26.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情提要："><a href="#前情提要：" class="headerlink" title="前情提要："></a>前情提要：</h2><h4 id="1、二叉树"><a href="#1、二叉树" class="headerlink" title="1、二叉树"></a>1、二叉树</h4><p>每一个节点最多有2个子节点，有左右之分。深度为n的二叉树，最多有2^n^ -1个节点，第n层最多有2^k-1^ 个节点。</p><h4 id="2、满二叉树"><a href="#2、满二叉树" class="headerlink" title="2、满二叉树"></a>2、满二叉树</h4><p>一棵深度为k，且有2^k^ -1个节点的树。</p><h4 id="3、完全二叉树"><a href="#3、完全二叉树" class="headerlink" title="3、完全二叉树"></a>3、完全二叉树</h4><p>完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。</p><p>若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一、二叉查找树（BST-binary-search-tree）"><a href="#一、二叉查找树（BST-binary-search-tree）" class="headerlink" title="一、二叉查找树（BST, binary search tree）"></a>一、二叉查找树（BST, binary search tree）</h3><p>某一节点的键值，一定大于其左子树的键值，一定小于其右子树的键值。</p><p><strong>为什么需要它？</strong> </p><blockquote><p>我们知道数组的搜索效率是O(1)，但是数组的插入、删除都需要移动元素，效率低下；而链表的插入、删除效率很高，但是其搜索效率是O(n)，效率低下。</p><p>这时候，二叉查找树就应运而生了。它具有插入、删除操作的高效和查找的高效。</p></blockquote><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/bt-1.png" alt="bt-1"></p><p><strong>实现：</strong>二叉查找树的实现简单，常用的操作就是插入、删除、查找节点。</p><p><strong>缺点：</strong>二叉查找树在插入有序元素的时候，会退化成链表。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/bt-2.png" alt="bt-2"></p><p><strong>中序遍历：</strong>一颗二叉查找树的中序遍历结果就是排序的结果。</p><blockquote><p>第一颗树的中序遍历结果是：3  4  7  10  12  13  17</p><p>第二棵树的中序遍历结果是：17  11  8  7  3  1</p></blockquote><h3 id="二、平衡二叉树（AVL）"><a href="#二、平衡二叉树（AVL）" class="headerlink" title="二、平衡二叉树（AVL）"></a>二、平衡二叉树（AVL）</h3><p>理论上，在插入元素的时候，动态调整二叉查找树，使其平衡（左右子树的最大深度不超过1）。平衡的二叉树就完美地实现了二分查找，同时其插入、删除的效率也是LogN。但是其实现时过于麻烦，仅仅作为理论来看待即可。</p><p><strong>特点：</strong>平衡二叉树在节点插入的过程中，会动态地调整树的结构，使得其每个节点的左、右子树的最大深度之差不会超过1。这样就维持了二叉树的稳定，从而使得插入、删除、查找的效率都处在log~2~N。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/bt-3.png" alt="bt-3"></p><p><strong>实现：</strong>在对节点的操作中，使用左旋、右旋来调整树的结构。理解左旋和右旋的意义，事实上，旋转的结果就是使得较为中间的数处在了树的中间位置；换个角度，我们有一组排好序的数组，那么我们要把它拎成一颗平衡的二叉树，当然就是位于中间的数处于二叉树的中间，这样才不会使二叉树左右不协调。</p><h3 id="三、2-3树"><a href="#三、2-3树" class="headerlink" title="三、2-3树"></a>三、2-3树</h3><p>作为平衡二叉树的一种变形，2-3数不再是二叉树了，而是一颗多叉树。它引入了2-节点和3-节点。3-节点就是该节点有2个key和3个子节点。在插入的时候，是自下而上来构建2-3树，由于2-3树插入节点的特性（新节点插入到2-或3-节点中，然后自下而上分裂），使得2-3树是完美平衡的。</p><p><strong>特点：</strong> 所有null节点到根节点的距离都是相同的。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/bt-4.png" alt="bt-4"></p><p><strong>实现：</strong> 2-3树的思想很好，同时也引出了2-3-4树甚至是n叉树。在MySQL的索引存储引擎中，使用的是B+Tree的结构，它就是多叉树的实现。</p><h3 id="四、红黑树"><a href="#四、红黑树" class="headerlink" title="四、红黑树"></a>四、红黑树</h3><p>2-3树在构建时，我们还是觉得麻烦，我们只想使用二叉查找树。这时候通过引入红黑节点及相关规定，我们可以构建一颗接近完美平衡的二叉查找树（因为2-3树是完美平衡的，而3-节点的拆分使得红黑树只能是接近完美平衡）。</p><p><strong>意义：</strong> 最终红黑树的实现，实际上就是一颗2-3树，2-3树可以与红黑树互相转换。</p><p><strong>延伸：</strong> jdk1.8之后，hashmap的底层，其原先存储值的链表结构改为了红黑树实现。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/bt-5.png" alt="bt-5"></p><h2 id="B-Tree与B-Tree"><a href="#B-Tree与B-Tree" class="headerlink" title="B-Tree与B+Tree"></a>B-Tree与B+Tree</h2><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>B-Tree是一种是磁盘等外存储设备设计的一种平衡查找树，它是多路平衡查找树。它的本质是一颗2-3-4-n树。为了减少磁盘指针移动的次数，多叉树尽量越矮胖越好。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/bt-6.png" alt="bt-6"></p><p><strong>特点：</strong> B-Tree的非叶子节点也会存储数据，这样会使得内存读取的索引页面更小，效率不高。</p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+Tree是B-Tree的升级版，它的非叶子节点只存储键值key，所有数据都存在最底层的叶子节点上。同时所有叶子节点之间都有一个链指针相连，这样有利于数据的范围查找和数据遍历。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/bt-8.png" alt="bt-8"></p><p>InnoDB和MyISAM都是B+Tree的实现。但是2者还是有区别的。</p><p><strong>InnoDB：</strong> </p><p><strong>InnoDB会有一个聚簇索引</strong>，一般是主键索引。该索引的B+Tree结构上，叶子节点存储了数据行的所有列，因此，一个数据表只能有一个聚簇索引。</p><p>InnoDB的二级索引，其叶子节点除了拥有key之外，还会保存主键列的值，因此二级索引需要根据主键值回表查找真正的数据。这意味着在设计二级索引的时候，我们可以使用覆盖索引来获取主键列的值。</p><p><strong>MyISAM：</strong></p><p>对于MyISAM来说，其主键索引和二级索引的结构是一样的。但是其叶子节点保存的只是数据的行指针，指向真正的数据。</p><p><strong>InnoDB和MyISAM的优缺点：</strong> </p><p>二者不同的实现在不同的场景下是各有优劣的，聚簇索引在读操作多、写操作少的时候，查找效率很高；而非聚簇索引在读操作少、写操作多的情况下，因为只需要修改key（B+Tree）的结构较少，如果是聚簇索引则需要耗费很大的资源。<strong>所以针对不同的读写场景，合理地选用表的存储引擎还是挺重要的。</strong> </p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/bt-7.png" alt="bt-7"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情提要：&quot;&gt;&lt;a href=&quot;#前情提要：&quot; class=&quot;headerlink&quot; title=&quot;前情提要：&quot;&gt;&lt;/a&gt;前情提要：&lt;/h2&gt;&lt;h4 id=&quot;1、二叉树&quot;&gt;&lt;a href=&quot;#1、二叉树&quot; class=&quot;headerlink&quot; title=&quot;1、二
      
    
    </summary>
    
    
      <category term="算法" scheme="https://blog.ibard.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://blog.ibard.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Queue接口的实现类</title>
    <link href="https://blog.ibard.cn/2018/09/Queue%E9%98%9F%E5%88%97/"/>
    <id>https://blog.ibard.cn/2018/09/Queue队列/</id>
    <published>2018-09-01T00:00:00.000Z</published>
    <updated>2018-10-05T11:37:20.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>queue作为队列，java在实现的时候，直接实现了双端队列deque。这样双端队列就囊括了队列、双端队列、堆栈这3种角色的功能。</p><p>所以我们在使用的时候使用的是Deque接口的实现类，当然Deque接口继承自Queue接口。</p></blockquote><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/queue-1.png-zoom50" alt="queue-1"></p><h2 id="Deque接口的实现类"><a href="#Deque接口的实现类" class="headerlink" title="Deque接口的实现类"></a>Deque接口的实现类</h2><p>我们记住，Deque接口所能代表的数据结构：队列，双端队列，堆栈。</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>1.内部使用<code>transient Object[] elements</code>数组来实现。拥有<code>head/tail</code>这2个头尾指针。最小初始化容量8。它还是一个循环队列。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/queue-2.png-zoom50" alt="queue-2"></p><p>2.在扩容/初始化的时候，数组的内部大小一定是2个幂次方，也就是说大小只可能是：8、16、32、64这样的倍增。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/queue-3.png-zoom75" alt="queue-3"></p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/queue-4.png-zoom50" alt="queue-4"></p><p>3.它作为堆栈、队列、双端队列的操作和LinkedList的操作是一致的，只是内部的实现不同。当然，它们也有区别。</p><p>ArrayDeque实现了双端队列，内部使用循环数组实现，这决定了它有如下特点：</p><ul><li>在两端添加、删除元素的效率很高，动态扩展需要的内存分配以及数组拷贝开销可以被平摊，具体来说，添加N个元素的效率为O(N)。</li><li>根据元素内容查找和删除的效率比较低，为O(N)。</li><li>与ArrayList和LinkedList不同，没有索引位置的概念，不能根据索引位置进行操作（无法随机访问，这也符合队列的性质）。</li></ul><p>4.操作示例</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/queue-5.png-zoom50" alt="queue-5"></p><p><img src="http://pd73wtntw.bkt.clouddn.com/201809/queue-6.png-zoom50" alt="queue-6"></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList的Deque性质在“List有序集合”中讲解了一遍。</p><h3 id="ArrayDeque和LinkedList的比较"><a href="#ArrayDeque和LinkedList的比较" class="headerlink" title="ArrayDeque和LinkedList的比较"></a>ArrayDeque和LinkedList的比较</h3><p>ArrayDeque和LinkedList都实现了Deque接口，应该用哪一个呢？如果只需要Deque接口，从两端进行操作，一般而言，ArrayDeque效率更高一些，应该被优先使用，不过，如果同时需要根据索引位置进行操作，或者经常需要在中间进行插入和删除，则应该选LinkedList（这里使用的是List特性，而不是Deque特性了）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;queue作为队列，java在实现的时候，直接实现了双端队列deque。这样双端队列就囊括了队列、双端队列、堆栈这3种角色的功能。&lt;/p&gt;
&lt;p&gt;所以我们在使用的时候使用的是Deque接口的实现类，当然Deque接口继承自Queue接口。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Queue接口" scheme="https://blog.ibard.cn/tags/Queue%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>tomcat与nginx反向代理</title>
    <link href="https://blog.ibard.cn/2018/09/tomcat%E4%B8%8Enginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://blog.ibard.cn/2018/09/tomcat与nginx反向代理/</id>
    <published>2018-09-01T00:00:00.000Z</published>
    <updated>2018-10-05T11:23:13.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、在linux上部署运行多个tomcat"><a href="#一、在linux上部署运行多个tomcat" class="headerlink" title="一、在linux上部署运行多个tomcat"></a>一、在linux上部署运行多个tomcat</h2><h3 id="1、以前的我们"><a href="#1、以前的我们" class="headerlink" title="1、以前的我们"></a>1、以前的我们</h3><p>虽然说是在linux上，但是windows上也是同样的道理，只不过我们服务器都是选用linux罢了。</p><p>原先，自己有多个项目需要部署在linux上时，我的做法（新手的做法）是：在linux上只有一个tomcat服务器，我们把多个项目如<code>project-1.war</code>、<code>project-2.war</code>、<code>project-3.war</code>（一般都是<em>.war</em>包的形式）都传输到这个tomcat的<code>webapps/</code>目录下；在启动tomcat后，tomcat自动解压war包成文件夹，然后我们通过地址+项目名的方法来访问项目。</p><p>比如：<code>192.168.1.1:8080/project-1/index.jsp</code>，<code>192.168.1.1:8080/project-2/index.jsp</code>等形式。</p><p><strong>缺点：</strong> 作为新手来说，这只是一个过渡的时期。我们发现，如果我们有时候想要重启服务器或关闭服务器（修改配置、项目之类的），所有的项目就都暂时无法访问了。而且tomcat每次启动都要重新加载所有的项目。简而言之，十分地不方便。</p><h3 id="2、学会部署运行多个tomcat"><a href="#2、学会部署运行多个tomcat" class="headerlink" title="2、学会部署运行多个tomcat"></a>2、学会部署运行多个tomcat</h3><p>我们可以运行多个tomcat，每一个tomcat都使用不同的端口号，这样我们就能随心所欲地部署我们的web项目了。当然，这里可能有多种搭配。如：单tomcat单项目，单tomcat多项目，多tomcat单项目，多tomcat多项目等。<strong>重要的是：使用多个tomcat可以让我们借助不同端口号来独立分隔不同的项目，个人觉得比较条理清楚</strong> </p><h4 id="2-1、多个tomcat运行单项目"><a href="#2-1、多个tomcat运行单项目" class="headerlink" title="2.1、多个tomcat运行单项目"></a>2.1、多个tomcat运行单项目</h4><p>下面讲解一下如何部署多个tomcat来运行同一个项目。假设我们的工作目录是<code>/opt/</code>，我们下载传输tomcat-xxx.zip到该目录下，解压<code>unzip tomcat-xxx.zip</code>后，重命名<code>mv tomcat-1</code>，这个就是我们的第一个tomcat服务器了。然后我们再复制一个<code>cp -a tomcat-1 tomcat-2</code>，这样就得到了第2个tomcat服务器。</p><p>接下来我们要配置这2个tomcat的端口，这样他们才能运行时端口号不冲突。下面的内容参考自网络，大家分享的都是差不多的。</p><p>1、打开配置文件，配置环境变量：<code>vim /etc/profile</code></p><p>2、在文件的最后几行加入配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># tomcat-1 config</span><br><span class="line">CATALINA_1_BASE=/opt/tomcat-1</span><br><span class="line">CATALINA_1_HOME=/opt/tomcat-1</span><br><span class="line">TOMCAT_1_HOME=/opt/tomcat-1</span><br><span class="line">export CATALINA_1_BASE CATALINA_1_HOME TOMCAT_1_HOME</span><br><span class="line"></span><br><span class="line"># tomcat-2 config</span><br><span class="line">CATALINA_2_BASE=/opt/tomcat-2</span><br><span class="line">CATALINA_2_HOME=/opt/tomcat-2</span><br><span class="line">TOMCAT_2_HOME=/opt/tomcat-2</span><br><span class="line">export CATALINA_2_BASE CATALINA_2_HOME TOMCAT_2_HOME</span><br></pre></td></tr></table></figure><p><strong>这里就是配置了我们自己的tomcat所在路径</strong></p><p>然后，我们要刷新文件使其生效：<code>source /etc/profile</code>。</p><p> 3、对tomcat进行相应的配置</p><p>我们先来到第一个tomcat下<code>cd /opt/tomcat-1/</code>，然后编辑第一个需要配置的文件：<code>vim /bin/catalina.sh</code>：</p><p>我们找到下面的内容：<code># OS specific support.  $var _must_ be set to either true or false.</code></p><p>然后在下面增加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export CATALINA_BASE=$CATALINA_1_BASE</span><br><span class="line">export CATALINA_HOME=$CATALINA_1_HOME</span><br></pre></td></tr></table></figure><p> 接着，我们编辑第二个需要配置的文件<code>vim /conf/server.xml</code>：找到下面3条信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;　               </span><br><span class="line"></span><br><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; /&gt;   </span><br><span class="line"></span><br><span class="line">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span><br><span class="line">    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><p>我们需要修改这3个端口号的值，以防止多个tomcat之间端口冲突。比如改成下面的端口号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server port=&quot;9005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;　               </span><br><span class="line"></span><br><span class="line">&lt;!-- tomcat访问端口 --&gt;</span><br><span class="line">&lt;Connector port=&quot;9080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; /&gt;   </span><br><span class="line"></span><br><span class="line">&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span><br><span class="line">    &lt;Connector port=&quot;9009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><p>4、这样，第1个tomcat就已经配置好了。我们这时候可以把项目<code>project-1.war</code>传输到<code>/opt/tomcat-1/webapps/</code>目录下，然后运行这个tomcat<code>/bin/startup.sh</code>。接着我们访问<code>192.168.1.1:9080/project-1/index.jsp</code>就能看到项目了。</p><p>5、<strong>小插曲：</strong></p><ul><li>可能会出现无法执行<code>startup.sh</code>文件的情况，提示没有权限，我们需要赋予执行权限<code>cd /opt/tomcat-1/bin/</code>，<code>chmod u+x *.sh</code>即可。</li><li>记得要开放linux对应的端口号，我用的是阿里云，所以就在控制台进行开发，你也可以使用<code>ufw</code>软件来进行开放。</li></ul><blockquote><p>第2个tomcat服务器的配置、运行的步骤和上面是一致的，只是选用的端口号不能重复，在配置完之后，我们就有2个tomcat服务器来运行同一个web项目了。</p><p>比如说：<code>192.168.1.1:9080/project-1/index.jsp</code>、<code>192.168.1.1:10080/project-1/index.jsp</code></p></blockquote><h4 id="2-2、想的再远一点，别轻易满足"><a href="#2-2、想的再远一点，别轻易满足" class="headerlink" title="2.2、想的再远一点，别轻易满足"></a>2.2、想的再远一点，别轻易满足</h4><p>其实上面这种多tomcat单个项目的方式，我们称之为tomcat集群。当然，上面的还很粗糙，只是一个小demo。</p><h5 id="问题1：指明不同的端口号访问（9080、10080）也太蠢了吧！"><a href="#问题1：指明不同的端口号访问（9080、10080）也太蠢了吧！" class="headerlink" title="问题1：指明不同的端口号访问（9080、10080）也太蠢了吧！"></a>问题1：指明不同的端口号访问（9080、10080）也太蠢了吧！</h5><p>的确很蠢，所以我们要慢慢过渡学习。接下来我们学习用nginx来进行反向代理。</p><hr><h2 id="二、使用nginx进行反向代理"><a href="#二、使用nginx进行反向代理" class="headerlink" title="二、使用nginx进行反向代理"></a>二、使用nginx进行反向代理</h2><p><a href="https://www.cnblogs.com/piscesLoveCc/p/5794926.html" target="_blank" rel="noopener">nginx的安装</a></p><blockquote><p>在上面的教程安装完成之后，如何启动呢？我建议把nginx的目录加到环境变量中。</p><p>在<code>/etc/profile</code> 中加入：</p><p>export NGINX_HOME=/usr/local/nginx<br>export PATH=$PATH:$NGINX_HOME/sbin</p><p>这样，就能直接使用<code>nginx -t</code>等命令了。</p></blockquote><p>在安装完成后，启动nginx，访问我们的地址<code>192.168.1.1</code>就可以看到nginx的欢迎页面了。</p><p><strong>曾经的一个bug：</strong> 遇到的情况是，无论如何修改配置都不能使其生效！通过<code>nginx -t</code>可以看到配置文件的路径：</p><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-1.png" alt="nginx-1"></p><p>那一次就是我找错了配置文件。也可以手动加载配置文件来启动：<code>nginx -t -c /usr/local/nginx/conf/nginx.conf</code>来先检查，然后读取配置文件启动。</p><h4 id="nginx常用的命令"><a href="#nginx常用的命令" class="headerlink" title="nginx常用的命令"></a>nginx常用的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 检查配置文件</span><br><span class="line">nginx -t</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line"># 停止</span><br><span class="line">nginx -s stop</span><br><span class="line"></span><br><span class="line"># 重新加载配置文件启动</span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line"># 指定配置文件启动</span><br><span class="line">nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line"># 查看nginx版本</span><br><span class="line">nginx -v</span><br><span class="line"></span><br><span class="line"># 摘自网络</span><br><span class="line">nginx -s stop       快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。</span><br><span class="line">nginx -s quit       平稳关闭Nginx，保存相关信息，有安排的结束web服务。</span><br><span class="line">nginx -s reload     因改变了Nginx相关配置，需要重新加载配置而重载。</span><br><span class="line">nginx -s reopen     重新打开日志文件。</span><br><span class="line">nginx -c filename   为 Nginx 指定一个配置文件，来代替缺省的。</span><br><span class="line">nginx -t            不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。</span><br><span class="line">nginx -v            显示 nginx 的版本。</span><br><span class="line">nginx -V            显示 nginx 的版本，编译器版本和配置参数。</span><br></pre></td></tr></table></figure><h3 id="1、先练个手，为不同端口配置虚拟主机"><a href="#1、先练个手，为不同端口配置虚拟主机" class="headerlink" title="1、先练个手，为不同端口配置虚拟主机"></a>1、先练个手，为不同端口配置虚拟主机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 找到安装的nginx</span><br><span class="line">whereis nginx</span><br><span class="line"></span><br><span class="line"># 进入安装目录</span><br><span class="line">cd /usr/local/nginx/</span><br><span class="line"></span><br><span class="line"># 编辑nginx配置文件</span><br><span class="line">vim conf/nginx.conf</span><br></pre></td></tr></table></figure><p>我们先找到下面这些信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面的配置，意思是：</p><blockquote><p>nginx监听服务器本地的80端口（建议把localhost改成自己的ip，更清晰），对外部访问的<code>/</code>进行代理，所以我们访问<code>192.168.1.1</code>就会看到nginx的欢迎页面。</p></blockquote><p>之前我们不是觉得加上端口号9080、10080很蠢吗，现在来改造一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 虚拟主机</span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  yeziqiduo.top;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /tomcat-1/ &#123;</span><br><span class="line">            proxy_pass http://yeziqiduo.top:9080/xmlconfig/;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /tomcat-2/ &#123;</span><br><span class="line">            proxy_pass http://yeziqiduo.top:10080/xmlconfig/;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们把localhost改成了自己的域名（当然你也可以用ip地址），然后添加了2个location的配置，意思是nginx监听到指定的server_name匹配到的location时，进行请求代理，即：<code>yeziqiduo.top/tomcat-1</code>的请求被代理给了我们设置的<code>http://yeziqiduo.top:9080/xmlconfig/</code>。第2个location的意思是一样的。</p><p>示意图如下：</p><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-2.png" alt="nginx-2"></p><p>浏览器监听请求转发（重定向）：可以明显看到先是301的永久重定向，请求被转发给了下一个url。</p><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-3.png" alt="nginx-3"></p><blockquote><p>这个练手，让我们明白了可以用nginx来映射请求url和服务器上的真实url。</p></blockquote><h3 id="2、再练下手，为不同的二级域名配置虚拟主机"><a href="#2、再练下手，为不同的二级域名配置虚拟主机" class="headerlink" title="2、再练下手，为不同的二级域名配置虚拟主机"></a>2、再练下手，为不同的二级域名配置虚拟主机</h3><p>如果我们使用主域名+项目名的url（<code>yeziqiduo.top/tomcat-1</code>、<code>yeziqiduo.top/tomcat-2</code>），看起来还是太low了啊。我觉得，用二级域名来代表不同的项目岂不是很爽吗？比如说：<code>book.yeziqiduo.top</code>、<code>movie.yeziqiduo.top</code>，就可以用来分别表示book项目和movie项目。</p><p>首先，我们要对我们的域名（yeziqiduo.top）添加2条A类型的解析记录，让<code>book.yeziqiduo.top</code>指向我们的ip地址。同理movie也是。</p><p>然后，我们再来编辑nginx的配置文件，（/usr/local/nginx/conf/nginx.conf.default是默认文件）我们可以添加多个server段来配置基于域名的虚拟主机。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 第一个虚拟主机</span><br><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  book.yeziqiduo.top;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass  http://yeziqiduo.top/book/;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  error_page   500 502 503 504  /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">  root   html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 第二个虚拟主机</span><br><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  movie.yeziqiduo.top;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">  proxy_pass  http://yeziqiduo.top/movie/;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  error_page   500 502 503 504  /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">  root   html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以通过2个二级域名的地址来访问服务器上的2个不同项目了。</p><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-4.png" alt="nginx-4"></p><blockquote><p>这种方式，是我们比较常用的方式，因为2级域名更加直观。毫无疑问，这种方式把第一种方式给碾压了。</p></blockquote><h3 id="3、正题来了，单项目的tomcat集群实现"><a href="#3、正题来了，单项目的tomcat集群实现" class="headerlink" title="3、正题来了，单项目的tomcat集群实现"></a>3、正题来了，单项目的tomcat集群实现</h3><p>当一个项目访问的人数多了之后，可能单个tomcat就支撑不住并发量了。这时候，我们希望有多台tomcat可以提供服务，理想的情况如下图：</p><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-5.png" alt="nginx-5"></p><p>在前面的2次练手后，我们可以很容易想明白。服务器端我们部署运行多个tomcat来实现单项目的集群。然后借助nginx来对请求进行代理，nginx依据某种策略把这些请求分发给不同的tomcat来处理。</p><p>为了方式调试，我们让tomcat-1和tomcat-2下的book项目有一点不同，就是主页index的显示不一样，这样才知道是哪个tomcat提供的服务。</p><p>我们来编辑配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 配置上游服务器集群</span><br><span class="line">upstream book_cluster &#123;</span><br><span class="line">  server  yeziqiduo.top:9080;</span><br><span class="line">  server  yeziqiduo.top:10080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 虚拟主机</span><br><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  book.yeziqiduo.top;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    # 如果服务器出错,则代理给下一台服务器</span><br><span class="line">    proxy_next_upstream  http_502 http_504 error timeout invalid_header;</span><br><span class="line">    proxy_pass  http://book_cluster/xmlconfig/;</span><br><span class="line">    proxy_set_header  Host book.yeziqiduo.top;</span><br><span class="line">    proxy_set_header  X-Forwarded-For $remote_addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  access_log  logs/book.yeziqiudo.top_access.log;</span><br><span class="line"></span><br><span class="line">  error_page   500 502 503 504  /50x.html;</span><br><span class="line">  location = /50x.html &#123;</span><br><span class="line">  root   html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要注意，upstream只能配置地址+端口，不能加上项目路径</strong>。我们将项目路径配置在proxy_pass字段，紧跟着集群地址后加上<code>/xmlconfig/</code>来指定这个tomcat集群的项目。</p><p>我们在浏览器多次访问，刷新，可以看到不同的tomcat提供的服务。</p><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-6.png-zoom75" alt="nginx-6"></p><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-7.png-zoom75" alt="nginx-7"></p><blockquote><p>相信看着，应该很激动了。到这里，我们接触到了比较粗浅的负载均衡。</p></blockquote><h4 id="问题：tomcat集群下，nginx如何选择策略来代理请求？"><a href="#问题：tomcat集群下，nginx如何选择策略来代理请求？" class="headerlink" title="问题：tomcat集群下，nginx如何选择策略来代理请求？"></a>问题：tomcat集群下，nginx如何选择策略来代理请求？</h4><p>nginx的upstream目前支持4种方式的分配<br>1、轮询（默认）<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>2、按权重分配weight<br>weight和访问比率成正比，用于后端服务器性能不均的情况。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">  server yeziqiduo.top:9080 weight=10;</span><br><span class="line">  server yeziqiduo.top:10080 weight=10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream bakend &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server yeziqiduo.top:9080;</span><br><span class="line">  server yeziqiduo.top:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、fair（第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  server yeziqiduo.top:9080;</span><br><span class="line">  server yeziqiduo.top:10080;</span><br><span class="line">fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、url_hash（第三方）<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。<br>例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  server yeziqiduo.top:9080;</span><br><span class="line">  server yeziqiduo.top:9080;</span><br><span class="line">  hash $request_uri;</span><br><span class="line">  hash_method crc32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、想一想，现在的问题又来了！"><a href="#4、想一想，现在的问题又来了！" class="headerlink" title="4、想一想，现在的问题又来了！"></a>4、想一想，现在的问题又来了！</h3><h4 id="1-现在我们只有一个服务器，如果并发量巨大，一台服务器上的单项目tomcat集群也是撑不住的。所以我们会来到分布式架构，演变为单项目多服务器集群的形式。（横向拓展远远优于硬件的纵向拓展）"><a href="#1-现在我们只有一个服务器，如果并发量巨大，一台服务器上的单项目tomcat集群也是撑不住的。所以我们会来到分布式架构，演变为单项目多服务器集群的形式。（横向拓展远远优于硬件的纵向拓展）" class="headerlink" title="1.现在我们只有一个服务器，如果并发量巨大，一台服务器上的单项目tomcat集群也是撑不住的。所以我们会来到分布式架构，演变为单项目多服务器集群的形式。（横向拓展远远优于硬件的纵向拓展）"></a>1.现在我们只有一个服务器，如果并发量巨大，一台服务器上的单项目tomcat集群也是撑不住的。所以我们会来到分布式架构，演变为单项目多服务器集群的形式。（横向拓展远远优于硬件的纵向拓展）</h4><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-8.png" alt="nginx-8"></p><h4 id="2-接着问题1，现在来到了分布式。那么新的问题就是：如何保持用户的session一致性？如何保证文件资源（如上传、下载）的一致性？"><a href="#2-接着问题1，现在来到了分布式。那么新的问题就是：如何保持用户的session一致性？如何保证文件资源（如上传、下载）的一致性？" class="headerlink" title="2.接着问题1，现在来到了分布式。那么新的问题就是：如何保持用户的session一致性？如何保证文件资源（如上传、下载）的一致性？"></a>2.接着问题1，现在来到了分布式。那么新的问题就是：如何保持用户的session一致性？如何保证文件资源（如上传、下载）的一致性？</h4><h4 id="3-分布式带来的问题不少，现在，单项目的tomcat集群又演变成了微服务架构。将一个大型的项目拆分，各个模块都独立运行提供服务，比如说拆分出单点登录系统、OSS（对象存储服务）等，能够解决一些问题2中的一些麻烦。"><a href="#3-分布式带来的问题不少，现在，单项目的tomcat集群又演变成了微服务架构。将一个大型的项目拆分，各个模块都独立运行提供服务，比如说拆分出单点登录系统、OSS（对象存储服务）等，能够解决一些问题2中的一些麻烦。" class="headerlink" title="3.分布式带来的问题不少，现在，单项目的tomcat集群又演变成了微服务架构。将一个大型的项目拆分，各个模块都独立运行提供服务，比如说拆分出单点登录系统、OSS（对象存储服务）等，能够解决一些问题2中的一些麻烦。"></a>3.分布式带来的问题不少，现在，单项目的tomcat集群又演变成了微服务架构。将一个大型的项目拆分，各个模块都独立运行提供服务，比如说拆分出单点登录系统、OSS（对象存储服务）等，能够解决一些问题2中的一些麻烦。</h4><h2 id="三、使用nginx强制http转https"><a href="#三、使用nginx强制http转https" class="headerlink" title="三、使用nginx强制http转https"></a>三、使用nginx强制http转https</h2><p>首先我们需要https的证书，免费提供https证书的网站有<a href="https://freessl.org/" target="_blank" rel="noopener">freessl</a>、<a href="https://letsencrypt.org/" target="_blank" rel="noopener">letsencrypt</a>、以及阿里云这3个网站。借助阿里云的单域名ssl证书，可以得到一个.key文件（私钥）和.pem文件（证书）。阿里云的ssl部分有一些配置的具体过程。在nginx的配置文件中，配置如下。对<code>yeziqiduo.top</code>启用了ssl即https连接，2个文件需要复制到linux中并指明路径。</p><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-9.png" alt="nginx-9"></p><p>然后我们想要强制http转成https连接，nginx配置如下：借助return重定向为https。（实现的方式还有其他几种）</p><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-10.png-zoom75" alt="nginx-10"></p><blockquote><p>由于阿里云提供的免费ssl证书只支持单域名，所有我们按照自己的需求申请多个证书并一一配置就可以了。</p></blockquote><h4 id="1、https的详细了解"><a href="#1、https的详细了解" class="headerlink" title="1、https的详细了解"></a>1、https的详细了解</h4><p>这部分内容，网上的博客分析地比较全面和透彻，看到好的文章多看看理解了才行。</p><blockquote><p>下面自己梳理一下一些关键的名词https的连接、传输过程。</p></blockquote><p>首先，我们知道申请得到的ssl文件：一个是私钥(private key)，另一个是证书(certificate)。我先讲一下什么是证书吧！借助Firefox可以查看网站的证书信息，重要的内容有：证书编号，过期时间，所有者信息，所有者公钥。</p><h5 id="1-下面讲解一下证书的生成过程："><a href="#1-下面讲解一下证书的生成过程：" class="headerlink" title="1.下面讲解一下证书的生成过程："></a>1.下面讲解一下证书的生成过程：</h5><blockquote><p>一个概念就是数字证书就好比网站的身份证，CA颁发给网站的证书就好比是一张张可信任的身份证。</p></blockquote><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-11.png" alt="nginx-11"></p><p>上面就是CA机构生成证书的过程，可以看到，证书中包含的内容有3部分：证书编号的数字签名值，网站的公钥，网站的信息。</p><h5 id="2-https的连接"><a href="#2-https的连接" class="headerlink" title="2.https的连接"></a>2.https的连接</h5><blockquote><p>https的连接，就是在tcp层和http层之间加了一层ssl层，所以需要先建立ssl连接，然后才开始http连接与通信。下面讲解一下，客户端如何与网站进行通信连接的建立。</p></blockquote><p>当客户端请求网站时，网站将证书发送给客户端，客户端如何判断发送的证书内容没有修改呢？这样我才能使用该证书的公钥进行通信！</p><p><img src="http://qiniu.yeziqiduo.top/201809/nginx-12.png" alt="nginx-12"></p><p>这个过程就是证书生成的逆过程。需要指出的是：<strong>CA的公钥哪里来的呢？</strong> 操作系统和浏览器会自己维护为数不多的CA机构列表。所以CA机构的公钥是在我们本地的。客户端使用同样的哈希方法（这个信息放在网站信息中）计算得到证书编号，同时使用CA公钥对数字签名值进行解密得到<strong>真实的证书编号</strong>，2者一对比，相等则说明该证书没有被篡改，可以信任并且使用其公钥。</p><p>1、如果证书被人修改，因为它没有CA的私钥，所以只能篡改网站公钥或网站信息这2部分的内容。客户端计算2个证书编号后就能知道信息是否被篡改。</p><p>2.如果证书被CA信任的其他网站劫持，发送过来的是被信任的网站的证书呢？客户端还会判断证书中网站信息里的域名是否和自己请求的域名一致，这样就能知道是否被中间人劫持了。</p><p><strong>证书验证通过之后，还要做更重要的事情！</strong></p><p>客户端生成随机数，并使用网站的公钥进行加密，发送给网站（<strong>中间人没有私钥，无法篡改</strong>）；网站收到密文后使用私钥进行解密得到随机数，并回复客户端。这个过程就是在协商后面的http通信所要使用的对称加密的密文。协商完成后，双方后面就开始进行http通信了，通信的内容都要使用密文进行对称加密（<strong>中间人不知道对称加密的密文，无法篡改</strong>），这样内容的安全性就得到了保证。</p><h4 id="2、总结一下https的过程"><a href="#2、总结一下https的过程" class="headerlink" title="2、总结一下https的过程"></a>2、总结一下https的过程</h4><p>HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。</p><p><strong>先使用非对称加密方式通信，验证网站身份以及取得公钥。然后双方协商对称加密的密文。后面双方的http通信就使用密文进行对称加密。</strong></p><blockquote><p>下面是参考的博文。</p></blockquote><p><strong>https博文列表：</strong></p><p>1.<a href="http://blog.jobbole.com/110354/" target="_blank" rel="noopener">也许，这样理解HTTPS更容易</a></p><p>2.<a href="https://github.com/youngwind/blog/issues/108" target="_blank" rel="noopener">图解 HTTPS：Charles 捕获 HTTPS 的原理</a></p><p>3.<a href="http://www.10tiao.com/html/195/201805/2658357634/1.html" target="_blank" rel="noopener">阿里云技术专家金九：Tengine HTTPS原理解析、实践与调试</a></p><p>4.<a href="http://liuduo.me/2018/05/14/https-detail/" target="_blank" rel="noopener">HTTPS 原理详解</a></p><p>5.<a href="https://cattail.me/tech/2015/11/30/how-https-works.html" target="_blank" rel="noopener">HTTPS工作原理</a></p><p>6.<a href="https://blog.upyun.com/?p=1347" target="_blank" rel="noopener">HTTPS 原理详解</a></p><h4 id="3、tcp的3次握手4次挥手"><a href="#3、tcp的3次握手4次挥手" class="headerlink" title="3、tcp的3次握手4次挥手"></a>3、tcp的3次握手4次挥手</h4><p><a href="https://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html" target="_blank" rel="noopener">HTTPS工作原理和TCP握手机制</a></p><h2 id="四、nginx的学习书籍"><a href="#四、nginx的学习书籍" class="headerlink" title="四、nginx的学习书籍"></a>四、nginx的学习书籍</h2><p>《精通nginx》、《实战nginx，取代apache的高性能服务器》</p><h2 id="五、nginx的配置文件"><a href="#五、nginx的配置文件" class="headerlink" title="五、nginx的配置文件"></a>五、nginx的配置文件</h2><p>nginx.conf文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line"># 工作进程数, 1.5*cpu核心数~2.0*cpu核心数</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 错误日志</span><br><span class="line">error_log  logs/error.log;</span><br><span class="line"></span><br><span class="line"># 记录主进程ID的文件</span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    # 使用网络IO模型,提高性能</span><br><span class="line">    use epoll;</span><br><span class="line">    # 一个工作进程worker process能处理的最大并发连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    # 其他配置</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    # 连接超时时长</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    # 开启gzip压缩</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_min_length  1k;</span><br><span class="line">    gzip_buffers    4  16k;</span><br><span class="line">    gzip_http_version  1.1;</span><br><span class="line">    gzip_comp_level  2;</span><br><span class="line">    gzip_types    text/plain application/x-javascript text/css application/xml;</span><br><span class="line"></span><br><span class="line">    # 第一个虚拟主机</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  yeziqiduo.top www.yeziqiduo.top;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 图片缓存30天</span><br><span class="line">        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ &#123;</span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line">        # css、js缓存1小时</span><br><span class="line">        location ~ .*\.(js|css|)?$ &#123;</span><br><span class="line">            expires 1h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 配置上游服务器集群</span><br><span class="line">    upstream book_cluster &#123;</span><br><span class="line"></span><br><span class="line">        # 最少连接数</span><br><span class="line">        least_conn;</span><br><span class="line">        # 默认轮询round-robin</span><br><span class="line">        # ip-hash</span><br><span class="line"></span><br><span class="line">        server  yeziqiduo.top:9080;</span><br><span class="line">        server  yeziqiduo.top:10080;</span><br><span class="line">        # 维持http连接的个数</span><br><span class="line">        keepalive  32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 第二个虚拟主机</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  book.yeziqiduo.top;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            # 引入配置文件</span><br><span class="line">            include proxy.conf</span><br><span class="line"></span><br><span class="line">            # http1.1才能维持连接</span><br><span class="line">            proxy_http_version  1.1;</span><br><span class="line">            proxy_set_header  Connection &quot;&quot;;</span><br><span class="line"></span><br><span class="line">            # 如果服务器出错,则代理给下一台服务器</span><br><span class="line">            proxy_next_upstream  http_502 http_504 error timeout invalid_header;</span><br><span class="line">            # 反向代理,设置上游服务器</span><br><span class="line">            proxy_pass  http://book_cluster/xmlconfig;</span><br><span class="line">            proxy_set_header  Host book.yeziqiduo.top;</span><br><span class="line">            proxy_set_header  X-Forwarded-For $remote_addr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        access_log  logs/book.yeziqiudo.top_access.log;</span><br><span class="line"></span><br><span class="line">        # 错误文件配置</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 第三个虚拟主机</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  movie.yeziqiduo.top;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 错误文件配置,外部网站</span><br><span class="line">        error_page  500 https://yeziqiduo.top:9080/xmlconfig/500.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 第四个虚拟主机</span><br><span class="line">    server &#123;</span><br><span class="line">        listen    80;</span><br><span class="line">        server_name    zstuhelper.yeziqiduo.top;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://mcrd.zstu.edu.cn/ZstuHelper/;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  www.yeziqiduo.top;</span><br><span class="line">    </span><br><span class="line">    ssl  on;</span><br><span class="line">        ssl_certificate      /usr/local/nginx/cert/1526572949495.pem;</span><br><span class="line">        ssl_certificate_key  /usr/local/nginx/cert/1526572949495.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_cache    shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name yeziqiduo.top;</span><br><span class="line">        </span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate      /usr/local/nginx/cert/215028086470218.pem;</span><br><span class="line">        ssl_certificate_key  /usr/local/nginx/cert/215028086470218.key;</span><br><span class="line">        </span><br><span class="line">        ssl_session_cache   shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line"></span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        </span><br><span class="line">        location / &#123;</span><br><span class="line">            root html;</span><br><span class="line">            index index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxy.conf文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 该配置文件可以重用</span><br><span class="line"># 下面的配置信息是nginx代理请求时连接上游服务器的参数</span><br><span class="line">proxy_redirect  off;</span><br><span class="line">proxy_set_header  Host  $host;</span><br><span class="line">proxy_set_header  X-Real-IP  $remote_addr;</span><br><span class="line">proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">client_max_body_size  10m;</span><br><span class="line">client_body_buffer_size  128k;</span><br><span class="line">proxy_connect_timeout  30;</span><br><span class="line">proxy_send_timeout  15;</span><br><span class="line">proxy_read_timeout  15;</span><br><span class="line">proxy_send_lowat  12000;</span><br><span class="line">proxy_buffer_size  4k;</span><br><span class="line">proxy_buffers  4 32k;</span><br><span class="line">proxy_busy_buffers_size  64k;</span><br><span class="line">proxy_temp_file_write_size  64k;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、在linux上部署运行多个tomcat&quot;&gt;&lt;a href=&quot;#一、在linux上部署运行多个tomcat&quot; class=&quot;headerlink&quot; title=&quot;一、在linux上部署运行多个tomcat&quot;&gt;&lt;/a&gt;一、在linux上部署运行多个tomcat&lt;/
      
    
    </summary>
    
    
      <category term="tomcat" scheme="https://blog.ibard.cn/tags/tomcat/"/>
    
      <category term="nginx" scheme="https://blog.ibard.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>日期（Date）与时间(Time)</title>
    <link href="https://blog.ibard.cn/2018/08/%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/"/>
    <id>https://blog.ibard.cn/2018/08/日期与时间/</id>
    <published>2018-08-01T00:00:00.000Z</published>
    <updated>2018-10-05T11:37:13.323Z</updated>
    
    <content type="html"><![CDATA[<p>在mysql中，与日期、时间相关的数据类型有：<code>DATE</code>、<code>TIME</code>、<code>DATETIME</code>、<code>TIMESTAMP</code> 这4种。</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>DATE</strong> </p><p>DATE就是日期，日期就是形如<code>YYYY-MM-DD</code> 格式的字符串，它的范围是：<code>1000-01-01</code>-<code>9999-12-31</code> 。官网上讲，允许使用strings和numbers的值。</p><p>在测试中，发现可以有2种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 1.strings</span><br><span class="line">insert table1 values(null, &apos;2018-7-8&apos;);</span><br><span class="line">-- 2.numbers</span><br><span class="line">insert table2 values(null, 20180202);</span><br></pre></td></tr></table></figure><p><strong>TIME</strong> </p><p>TIME就是时间，时间就是我们生活中口头上的时间了，形如：<code>HH:MM:SS</code>，就是小时-分钟-秒数。它不仅可以表示一天当中的具体时间，还可以表示2个时间点之间的差值。比如说，前天和今天相差了2天的时间，就是：<code>48:00:00</code> 的表示。同样，官网上给出了strings和numbers的可用值形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 1.strings</span><br><span class="line">insert table2 values(null, &apos;16:24:44&apos;);</span><br><span class="line">insert table2 values(null, &apos;124:42:33&apos;);</span><br><span class="line">-- 2.numbers</span><br><span class="line">insert table2 values(null, 172550);</span><br></pre></td></tr></table></figure><p>实际上，真正的TIME的格式为：<code>HH:MM:SS[.fraction]</code> ，可以附带小数位，如：<code>16:42:55.000000</code> ，考虑到实际中没什么用，不用特意提及。</p><p><strong>DATETIME</strong> </p><p>DATETIME，在官网上给出的定义是：DATE和TIME的结合体。它就表示一个具体的日期+时间。格式为：<code>YYYY-MM-DD HH:MM:SS</code> ，范围是：<code>1000-01-01 00:00:00</code>-<code>9999-12-31 23:59:59</code> 。同样，可以使用strings和numbers的值形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 1.strings</span><br><span class="line">insert table3 values(null, &apos;2018-03-03&apos;);  # TIME省略时，TIME会自动补为0</span><br><span class="line">insert table3 values(null, &apos;2018-02-3 14:22:34&apos;);</span><br><span class="line">-- 2.numbers</span><br><span class="line">insert table4 values(null, 20180405);  # TIME省略时，TIME会自动补为0</span><br><span class="line">insert table4 values(null, 20180505152243);</span><br></pre></td></tr></table></figure><p>实际上，真正的DATETIME的格式为：<code>DATETIME[(fsp)]</code>-&gt;<code>YYYY-MM-DD HH:MM:SS[.fraction]</code> ，fsp的值为0-6，用来限定fraction的长度。因为在实际中用不上，我们也不用关注。</p><p><strong>TIMESTAMP</strong> </p><p>TIMESTAMP，表示时间戳。它和DATETIME有很多相似的地方。我只关注实际中切实用到的部分。首先，在插入值的语法上和DATETIEM别无二致。能使用strings和numbers的形式。完全和DATETIME的插入举例一样。其次，有一个很大的限制就是，它的范围是：<code>1970-01-01</code>-<code>2038-01-19</code> ，在这个范围外面的时间是无效的。</p><p>至于为什么日期时间的范围有差别，这和数据类型的存储结构有关，这里不提。</p><h3 id="实际中的用法"><a href="#实际中的用法" class="headerlink" title="实际中的用法"></a>实际中的用法</h3><p>这里，主要讲的是在项目的设计应用中，mysql数据库所选择的日期时间的数据类型。</p><p><strong>1、DATE</strong> </p><p>我们常用的出生日期这一列，就是典型的<code>YYYY-MM-DD</code>的格式。所以对于这一类的数据，我们都采用DATE。</p><p><strong>2、TIMESTAMP</strong> </p><p>与DATE相比，TIMESTAMP还可以存储TIME部分，对于像一些操作的时间列来说，比如说登录时间、修改时间等这些操作，我们会尽可能地保存更加精确的时间。而且实际中，我们更切实的需求是最后一次的登录时间、修改时间，这也和TIMESTAMP的特性完全符合。</p><p>那DATETIME也可以做到，会不会使用DATETIME呢？答案是不会，由于储存空间的原因，DATETIME占用8个字节(8 byte)，而TIMESTAMP只占用4个字节(4 byte)，相同的需求功能下，我们当然选择使用TIMESTAMP。</p><blockquote><p>当然，TIMESTAMP一个限制就是日期的范围，当我们需要用到2038以后的时间时，就要改用DATETIME了。</p></blockquote><p><strong>再谈TIMESTAMP和DATETIME</strong> </p><p>除了储存空间上的优势，TIMESTAMP还包含了时区的信息，在不同的时区，TIMESTAMP列显示的日期时间是不同的。当然，现在我们用不到时区，先了解一下。既然我们提到，实际生产中尽量用TIMESTAMP，那么TIMESTAMP还有哪些特性呢？</p><ol><li><p>可以为null。</p></li><li><p>TIMESTAMP列的默认属性。<br>当我们创建一个表，包含了TIMESTAMP列时。我们再使用<code>show create table tb_name</code> 来查看建表语句，就会发现有趣的现象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`last_login_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br></pre></td></tr></table></figure><p>建表语句说明：TIMESTAMP列默认是not null的，而且默认值是建表的时间，还有，当该行数据数据更新的时候，这个字段会自动更新为修改时间。</p><p>换句话说，对于我们实际中最后一次登录时间等类似的需求，我们只需要在建表时候定义这个字段，那么以后的操作都可以不涉及这个字段了，因为它会自动更新。</p></li></ol><p>对于第2个特性，如果我们想要自定义使用的话，就需要在建表语句中指明TIMESTAMP列的具体行为。下面给出几条参考语句：一般用不到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 1.以后该列不自动更新（取消on update）</span><br><span class="line">last_login_time timestamp default current_timestamp;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在mysql中，与日期、时间相关的数据类型有：&lt;code&gt;DATE&lt;/code&gt;、&lt;code&gt;TIME&lt;/code&gt;、&lt;code&gt;DATETIME&lt;/code&gt;、&lt;code&gt;TIMESTAMP&lt;/code&gt; 这4种。&lt;/p&gt;
&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://blog.ibard.cn/tags/mysql/"/>
    
      <category term="date与time" scheme="https://blog.ibard.cn/tags/date%E4%B8%8Etime/"/>
    
  </entry>
  
  <entry>
    <title>好用的`java.util.Objects`类</title>
    <link href="https://blog.ibard.cn/2018/08/%E5%A5%BD%E7%94%A8%E7%9A%84Objects%E7%B1%BB/"/>
    <id>https://blog.ibard.cn/2018/08/好用的Objects类/</id>
    <published>2018-08-01T00:00:00.000Z</published>
    <updated>2018-10-05T11:37:10.497Z</updated>
    
    <content type="html"><![CDATA[<p>在jdk1.7中，新增了一个工具类，就是<code>java.util.Objects</code>类。它有3个简单的封装方法，对于平常的使用来说挺有用的，分别是：<code>hashCode</code>、<code>equals</code>、<code>toString</code>这3个方法。</p><h4 id="1、hashcode生成"><a href="#1、hashcode生成" class="headerlink" title="1、hashcode生成"></a>1、hashcode生成</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Objects.hash(Object... values)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Arrays.hashCode(Object a[])</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Object element : a)</span><br><span class="line">    result = <span class="number">31</span> * result + (element == <span class="keyword">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Object.hashCode()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>首先，Objects的hash方法接收可变参数，可变参数的内部是一个数组。然后内部调用Arrays的hashCode方法，我们来看一下其方法：核心是遍历每一个参数来计算result值，在计算的过程中，每一个参数上转型为Object使用hashCode来生成随机值。那么Object的hashCode又是什么？这是一个本地方法，源码不给出实现，其数值和对象的内存地址有关。</p><blockquote><p>参数虽然上转型为Object，但是对于String、Integer等对象类型，它们都重写了hashCode方法。</p><p>因为是基于内存地址的生成，所以不同对象生成的hashcode值冲突的几率是很小的。</p></blockquote><h4 id="2、对象equals比较"><a href="#2、对象equals比较" class="headerlink" title="2、对象equals比较"></a>2、对象equals比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Objects.equals(Object a, Object b)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Object.equals(Object obj)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是对象的引用判断，其次就是调用对象自身的equals方法来比较，如果对象类型没有重写equals的话，就会调用Object的equals方法（仍然是对象的引用比较）。</p><blockquote><p>事实上，我们进行equals比较的对象，除了引用对象之外，就是String、Integer（自动装箱后）等类型了。</p><p>对于String，直接进行引用比较。而对于Integer、Double等对象类型，它们都重写了equals方法，贴出Integer的equals方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">&gt;   <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">&gt;   <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可以看到，内部是进行值相等判断。</p></blockquote><h2 id="hashCode与equals方法的重要性"><a href="#hashCode与equals方法的重要性" class="headerlink" title="hashCode与equals方法的重要性"></a>hashCode与equals方法的重要性</h2><p>对于散列结构（hash）的集合类型，比如说HashMap、HashSet等，如果我们用它们来存储我们自定义的对象，那么我们就必要重写类的hashCode与equals方法。<u>为什么要重写，这个原因就不赘述了。</u> 还有Set集合类，由于它存储不重复的元素。</p><p>下面我们给出利用Objects工具类的一种较为简单实用的重写方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Building</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> area;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 引用相等判断</span></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 类型判断</span></span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Building)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Building building = (Building) obj;</span><br><span class="line">      <span class="comment">// 关键域相等判断</span></span><br><span class="line">        <span class="comment">// 基本类型不要用用Objects.equals()方法，会自动装箱带来额外开销</span></span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, building.name) &amp;&amp; (area == building.area);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.toString(<span class="string">"name = "</span> + name, <span class="string">"name is undefined"</span>) + <span class="string">", "</span></span><br><span class="line">                + Objects.toString(<span class="string">"area = "</span> + area, <span class="string">"area is undefined"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setter、getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、toString"><a href="#3、toString" class="headerlink" title="3、toString"></a>3、toString</h4><p>我们自己重写toString方法时，有一点比较难写，就是默认值设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Objects.toString(Object o, String nullDefault)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(Object o, String nullDefault)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (o != <span class="keyword">null</span>) ? o.toString() : nullDefault;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Objects.toStirng(Object 0)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> String.valueOf(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在重写toString时，可以参考上面的<code>Building</code>类的写法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在jdk1.7中，新增了一个工具类，就是&lt;code&gt;java.util.Objects&lt;/code&gt;类。它有3个简单的封装方法，对于平常的使用来说挺有用的，分别是：&lt;code&gt;hashCode&lt;/code&gt;、&lt;code&gt;equals&lt;/code&gt;、&lt;code&gt;toStrin
      
    
    </summary>
    
    
      <category term="java.util.Objects" scheme="https://blog.ibard.cn/tags/java-util-Objects/"/>
    
  </entry>
  
  <entry>
    <title>Java中的数值类型选择</title>
    <link href="https://blog.ibard.cn/2018/08/Java%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9/"/>
    <id>https://blog.ibard.cn/2018/08/Java中的数值类型选择/</id>
    <published>2018-08-01T00:00:00.000Z</published>
    <updated>2018-10-05T11:37:07.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>有byte(1 byte)，short(2 byte)，int(4 byte)，long(8 byte)等基本数据类型，取值的范围不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> x1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> x2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> x3 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">long</span> x4 = <span class="number">4L</span>;</span><br></pre></td></tr></table></figure><h2 id="涉及到有小数的数值"><a href="#涉及到有小数的数值" class="headerlink" title="涉及到有小数的数值"></a>涉及到有小数的数值</h2><p>这种场景也是要分情况讨论的。</p><h4 id="1-货币、金钱的计算"><a href="#1-货币、金钱的计算" class="headerlink" title="1.货币、金钱的计算"></a>1.货币、金钱的计算</h4><p>当涉及到人民币、美元的计算时，比如说人民币RMB，单位有元、角、分，我们可以参考腾讯微信的做法，把金钱都乘以100，转化为以分为整数的计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100.1</span> -&gt; <span class="number">100</span>元<span class="number">1</span>角</span><br><span class="line"><span class="number">100.02</span> -&gt; <span class="number">100</span>元零<span class="number">2</span>分</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> m1 = <span class="number">100.1f</span>;</span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">100.02</span>d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单位转换，小数值转整数</span></span><br><span class="line"><span class="keyword">int</span> money1ByCent = (<span class="keyword">int</span>)(m1 * <span class="number">100</span>); <span class="comment">// 10010,以分作为最小单位来计算，把小数给转化掉</span></span><br><span class="line"><span class="keyword">int</span> money2ByCent = (<span class="keyword">int</span>)(d1 * <span class="number">100</span>);  <span class="comment">// 10002,同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数计算，结果转回小数值</span></span><br><span class="line"><span class="keyword">int</span> sub = money1ByCent - money2ByCent;</span><br><span class="line"><span class="keyword">float</span> f2 = (<span class="keyword">float</span>) (sub * <span class="number">1.0</span> / <span class="number">100</span>)  <span class="comment">// 转化为float存储</span></span><br></pre></td></tr></table></figure><p>值得注意的是，在int计算完成后，转换回float的过程中，<strong>对于int -&gt; float的计算，我们应该显式地乘以1.0（带入float类型）</strong>这样也会带来(checked exception)帮助我们进行显式转换；否则它仍然是进行int型的计算。有趣的是，我们在float-&gt;int的过程中，checked exception也帮助我们进行了显式转换，这一点是很重要的。</p><h4 id="2-含小数的数字表示"><a href="#2-含小数的数字表示" class="headerlink" title="2.含小数的数字表示"></a>2.含小数的数字表示</h4><p>如果小数只是用来存储和表示，那么还是可以使用float和double的。比如我们在javabean对象的属性里面，<strong>使用float和double来定义属性的数据类型</strong>，并为其生成getter和setter方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class Book &#123;</span><br><span class="line">  <span class="keyword">float</span> price;</span><br><span class="line">  <span class="keyword">double</span> weight;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// getter、setter省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这里又使用float和double来表示呢？因为对于javabean的属性而言，我们只是用float和double来保存一些数值，并不会用它们直接进行计算。所以不会造成精度的损失。相比较于BigDecimal，这样更加节约空间。</p><p>这里，简答提一下float和double。2者都有符号位，可以表示正负。float：(4byte，e+-38)；double：(8byte，e+-308)。<strong>我们给出结论：</strong>如果要用到float和double，那么float的范围足够我们使用了。</p><h4 id="3-科学计算"><a href="#3-科学计算" class="headerlink" title="3.科学计算"></a>3.科学计算</h4><p>当我们一定要进行小数的计算时，不是货币、金钱那种简单的转化就能实现的。我们应该使用<code>java.math.BigDecimal</code>这个数据类型。它可以精确进行计算，虽然计算有点麻烦，速度有点慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal i1 = <span class="keyword">new</span> BigDecimal(<span class="string">"22.33321"</span>);</span><br><span class="line">BigDecimal i2 = <span class="keyword">new</span> BigDecimal(<span class="string">"3.1242"</span>);</span><br><span class="line">BigDecimal divide = i1.divide(i2, <span class="number">2</span>);  <span class="comment">// 保留精度，防止无限不循环</span></span><br><span class="line">BigDecimal add = i1.add(i2);</span><br></pre></td></tr></table></figure><p>对于乘法和除法，会出现小数点位数比较多的情况，<strong>除法更是有可能无限不循环，所以一般需要设置精度</strong>。当然，还有更加复杂的操作，可以去细看API文档。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果我们用不到小数，就使用整数类型。</p><p>如果需要使用小数进行计算，那么有2种方案：</p><ol><li>金额类小数，转换为int计算，再转换为小数返回</li><li>其他小数，使用BigDecimal类进行计算</li></ol><p>如果我们仅仅使用小数进行表示，可以使用float、double来表示属性，进行getter、setter方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整数类型&quot;&gt;&lt;a href=&quot;#整数类型&quot; class=&quot;headerlink&quot; title=&quot;整数类型&quot;&gt;&lt;/a&gt;整数类型&lt;/h2&gt;&lt;p&gt;有byte(1 byte)，short(2 byte)，int(4 byte)，long(8 byte)等基本数据类型，取值
      
    
    </summary>
    
    
      <category term="数值类型" scheme="https://blog.ibard.cn/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>java项目中的classpath到底是什么</title>
    <link href="https://blog.ibard.cn/2018/07/classpath%E8%B7%AF%E5%BE%84%E8%A7%A3%E8%AF%BB/"/>
    <id>https://blog.ibard.cn/2018/07/classpath路径解读/</id>
    <published>2018-07-01T00:00:00.000Z</published>
    <updated>2018-10-05T11:36:58.843Z</updated>
    
    <content type="html"><![CDATA[<p>在java项目中，你一定碰到过classpath，通常情况下，我们是用它来指定配置/资源文件的路径。在刚开始学习的时候，自己也糊里糊涂，但是现在，是时候弄清楚它到底是指什么了。</p><p><strong>顾名思义</strong>，classpath就是class的path，也就是类文件(*.class的路径)。一谈到文件的路径，我们就很有必要了解一个java项目（通常也是web项目）它在真正运行时候，这个项目内部的目录、文件的结构；这样，我们才好分析、理解classpath。</p><h2 id="开发时期的web项目结构"><a href="#开发时期的web项目结构" class="headerlink" title="开发时期的web项目结构"></a>开发时期的web项目结构</h2><p>下面，我以一个ssm的项目为例，我先把开发时候的项目的目录结构图放出来。根据maven的约定，一般我们的项目结构就像下面这样。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/p1.png-fixedw600" alt="maven项目结构"></p><h2 id="classpath用在哪里了？"><a href="#classpath用在哪里了？" class="headerlink" title="classpath用在哪里了？"></a>classpath用在哪里了？</h2><p>而我们经常用到classpath的地方，就是在指定一些配置/资源文件的时候会使用到。比如说，我们在web.xml中指定springmvc的配置文件，如下图，我们使用：<code>classpath:entry/dev/spring-mvc.xml</code>；再比如，当我们把*Mapper.xml文件放在了<code>main/java/../mapping/</code>文件夹下时，在mybatis的配置文件中配置其位置，我们使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath*:**/mapper/mapping/*Mapper.xml</span><br></pre></td></tr></table></figure><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/p2.png-zoom75" alt="classpath1"></p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/p5.png-zoom50" alt="classpath2"></p><p>很显然，上面这2个classpath的配置，是为了告诉配置文件，去哪里寻找我们要指定的配置文件。要想弄清楚为什么是上面这样写的，我们就要来看看项目运行时（或者是发布后）的目录结构了。</p><h2 id="web项目发布后的目录结构"><a href="#web项目发布后的目录结构" class="headerlink" title="web项目发布后的目录结构"></a>web项目发布后的目录结构</h2><p>我们使用IDEA对项目进行打包，一种是war包，一种是explorer的文件夹，war包解压后就是explorer了。我们来对解压后的目录结构进行分析。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/p3.png-fixedh400" alt="struct1"></p><p>经过对比，我们要注意到，开发时期的项目里，<code>src/main/</code>下面的<code>java</code>和<code>resources</code>文件夹都被(编译)打包到了生产包的<code>WEB-INF/classes/</code>目录下；而原来WEB-INF下面的views和web.xml则仍然还是在WEB-INF下面。同时由maven引入的依赖都被放入到了<code>WEB-INF/lib/</code>下面。<strong>最后，编译后的class文件和资源文件都放在了classes目录下。</strong> </p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/p4.png" alt="struct2"></p><h2 id="classpath原来是这个"><a href="#classpath原来是这个" class="headerlink" title="classpath原来是这个"></a>classpath原来是这个</h2><p>在编译打包后的项目中，根目录是<code>META-INF</code>和<code>WEB-INF</code> 。这个时候，我们可以看到classes这个文件夹，它就是我们要找的classpath。</p><p>在第1个例子里，<code>classpath:entry/dev/spring-mvc.xml</code>中，classpath就是指<code>WEB-INF/classes/</code>这个目录的路径。需要声明的一点是，使用<code>classpath:</code>这种前缀，<strong>就只能代表一个文件</strong>。</p><p>在第2个例子里，<code>classpath*:**/mapper/mapping/*Mapper.xml</code>，使用<code>classpath*:</code>这种前缀，<strong>则可以代表多个匹配的文件</strong>；<code>**/mapper/mapping/*Mapper.xml</code>，双星号<code>**</code>表示在任意目录下，也就是说在<code>WEB-INF/classes/</code>下任意层的目录，只要符合后面的文件路径，都会被作为资源文件找到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在java项目中，你一定碰到过classpath，通常情况下，我们是用它来指定配置/资源文件的路径。在刚开始学习的时候，自己也糊里糊涂，但是现在，是时候弄清楚它到底是指什么了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顾名思义&lt;/strong&gt;，classpath就是class的pa
      
    
    </summary>
    
    
      <category term="classpath" scheme="https://blog.ibard.cn/tags/classpath/"/>
    
  </entry>
  
  <entry>
    <title>http请求（GET/POST）时，url/参数编码的过程分析</title>
    <link href="https://blog.ibard.cn/2018/07/http%E8%AF%B7%E6%B1%82%E7%9A%84url%E7%BC%96%E7%A0%81/"/>
    <id>https://blog.ibard.cn/2018/07/http请求的url编码/</id>
    <published>2018-07-01T00:00:00.000Z</published>
    <updated>2018-10-05T11:37:02.700Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这个实验，是在采用ssm框架的基础上演示的。</p></blockquote><p>在前端向后端发出http请求时，有时候当我们采用GET方式时，参数会被编码在url后面。那么这个url是如何编码解码的呢？</p><h2 id="http请求的发出，以及编码过程"><a href="#http请求的发出，以及编码过程" class="headerlink" title="http请求的发出，以及编码过程"></a>http请求的发出，以及编码过程</h2><p>下面在chrome浏览器和postman下模拟请求，用fiddler来监控请求发出信息。</p><p><strong>chrome游览器地址输入</strong>： </p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/b1.png" alt="chrome_url"></p><p>这个路径是手动输入的，黑色线是url，黄色线是uri，绿色线是queryString。这时F12，然后我们<strong>路径按下回车</strong>。</p><p><strong>chrome地址</strong>：</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/b2.png" alt="chrome_url2"></p><p><strong>chrome监控</strong>： </p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/b3.png" alt="chrome_url3"></p><p><strong>fiddler监控</strong>： </p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/b4.png" alt="fidder_url"></p><p>我们关注chrome控制台和fiddler的情况，可以发现，chrome发出这个http请求的时候，对查询参数进行了编码。我们在网站(<a href="https://www.bejson.com/convert/ox2str/" target="_blank" rel="noopener">https://www.bejson.com/convert/ox2str/</a>) 进行Hex转字符的操作，可以发现：中文字符被编码成16进制数，而且每个字节(byte)的16进制数前都被浏览器加上了一个%。（下图中，20E8B083这4个字节对应“调”，E4BC98这3个字节对应“优”）</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/b5.png-zoom75" alt="translation"></p><p><strong>浏览器编码url的风格：</strong> 到这里，可能你有点迷惑了。我来解释一下，根据URL的编码规范，浏览器会把URL中的非ASCII字符按照某种编码格式（chrome是utf-8）编码成byte数组后，转成16进制数字，然后在每个16进制数字前加上%分隔。</p><p>到现在，应该清楚了浏览器GET传参时的编码过程了。值得一提的是，在实践中，我们最糟糕也只会在GET方式的url后面携带中文参数，在servletPath（也就是?前的一段）中我们不会去用中文的，除非你自找麻烦。</p><p><strong>具体的传输：</strong> 其实，我们还没有讲到url的传输。我们要知道，在网络世界的传输中，所有的信息都是以字节传输的（byte[])，一个http请求的所有内容都是编码成byte数组后传输的，也就是0101这样的数字。为了方便显示，fiddler中用Hex来表示。可以这么理解，上面那个url路径只是一个初步处理后的string而已，我们从fiddler中查看，</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/b6.png" alt="url_encode"></p><p>我们对Hex进行几次copy查看：</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/b7.png" alt="encode2"></p><p>可以看出，传输过程中的Hex数组，就是我们之前监控到的真正的http请求url经过了中文utf-8编码后的路径。</p><h2 id="http请求的接收，以及解码过程"><a href="#http请求的接收，以及解码过程" class="headerlink" title="http请求的接收，以及解码过程"></a>http请求的接收，以及解码过程</h2><h3 id="需不需要设置解码呢？"><a href="#需不需要设置解码呢？" class="headerlink" title="需不需要设置解码呢？"></a>需不需要设置解码呢？</h3><p>答案是肯定的，手动设置一下肯定是非常好的。</p><h4 id="url-url的解码过程"><a href="#url-url的解码过程" class="headerlink" title="url/url的解码过程"></a>url/url的解码过程</h4><p>下面我们以tomcat为例，当上面那一大串byte数组传输到服务器后，首先，tomcat会对uri部分进行解码，这里charset由tomcat配置文件中的<code>&lt;Connector URIEncoding=&quot;UTF-8&quot;</code>决定，不设置的话默认值为<code>ISO-8859-1</code>。由于域名和端口只会是英文，比如说：<code>www.baidu.com</code>,<code>www.google.com</code>；同时我们上面讲过，在uri部分我们不会去用中文，我们只会采用英文。因此，对于url这一块，无论是采用<code>UTF-8</code>还是<code>ISO-8859-1</code>解码，url这部分内容都不会乱码。到这一步，我们服务器端就解码得到了<code>localhost:8082/article/queryByTitle</code>。</p><h4 id="queryString的解码过程"><a href="#queryString的解码过程" class="headerlink" title="queryString的解码过程"></a>queryString的解码过程</h4><p>上面，我们知道了uri/url这一块的内容解码过程。下面，我们来看看queryString这部分的解码过程。</p><p>我们在chrome中，F12查看http请求的详细信息，可以发现查询参数被作为parameters保存了下来。这里，可以告诉大家，通过GET方式发出http请求所携带的queryString以及通过POST方式发出http请求所携带的表单参数，也就是GET、POST这2种方式携带的参数，都会被作为parameters保存；在服务器端通过request.getParameter()方法可以获取到值。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/b8.png" alt="parameters"></p><p>下面以GET方式的queryString的解码过程来讲解。首先我们思考一下，如何才能得到原来的中文呢？当然是先把Hex数字使用UTF-8转码一次，得到浏览器初步处理的参数，如：<code>title=JVM%20%E8%B0%83%E4%BC%98</code>，然后再对原来非ASCII字符的部分使用UTF-8转码一次，得到最初值：<code>title=JVM 调优</code>。中文这一块我也没找到相关资料，我就分析一下英文的解码过程吧。</p><h5 id="1-英文参数的解码"><a href="#1-英文参数的解码" class="headerlink" title="1.英文参数的解码"></a>1.英文参数的解码</h5><p>假设我们原有的请求并不含中文参数，比如说：<code>title=JVMoptimize</code> 。那么在服务器端调用request.getParameter的方法时，会先进行转码，而charset由http请求的header中的contentType决定，否则使用<code>ISO-8859-1</code>。要想使用contentType的charset，还需要把<code>&lt;Connector URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot; /&gt;</code>设置为true，注意，true只是设置queryString的解码。到这里，对Hex的解码就会采用contentType的UTF-8进行解码了，我们就可以还原得到<code>title=JVMoptimize</code>了，然后取到<code>JVMoptimize</code>这个参数值。</p><h5 id="2-中文参数的解码"><a href="#2-中文参数的解码" class="headerlink" title="2.中文参数的解码"></a>2.中文参数的解码</h5><p>我们再来讲一讲中文参数的问题，因为在chrome中，非ASCII字符会采用UTF-8先进行一次编码；那么其实在服务器端，我们可以自己思考一下。因为如果是纯英文的参数，下图是<code>title=JVM optimize</code>的请求，在初步处理时，空格是Hex的%20，也就是说纯英文下%后面一定是20，%20代表了一个空格。而如果是中文参数，因为浏览器手动在每一个字节前加了%，注意，这样我们服务器端通过%和其后面的是否跟着20就可以知道这里是空格还是代表着中文参数了。</p><p><img src="http://pd73wtntw.bkt.clouddn.com/201807/b9.png" alt="experiment"></p><p>我们可以做出设想，在对queryString进行第一次转码之后，可能有2种基本情况：</p><ul><li>纯英文，还有空格的参数。原参数如：<code>title=JVM optimize</code> 。<br>那么第一次转码，会得到：<code>title=JVM%20optimize</code> 。</li><li>中文，还有空格的参数。原参数如：<code>title=JVM 调优</code>。<br>那么第一次转码。会得到：<code>title=JVM%20%E8%B0%83%E4%BC%98</code>。</li></ul><h4 id="queryString的解码过程猜想"><a href="#queryString的解码过程猜想" class="headerlink" title="queryString的解码过程猜想"></a>queryString的解码过程猜想</h4><p>这个时候的结果就很明确了。我猜测，这时候服务器内部应该会对%进行检测，然后做出相应的处理。下面是我的猜测：</p><p>如果检测到%，那么看看其后面是否跟着20？是的话，就表示这是一个空格，将其转化（解码）为空格<code>&quot; &quot;</code>；不是的话，代表这一块将是中文字符（或其他非ASCII字符，如日文，韩文），就把这一块连续的%剔除，再用UTF-8转码，就得到了中文字符。</p><p>上面应该是挺靠近真实情况的解释了，因为肯定对非ASCII的解码要进行2次，上面的依据也挺充足的。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>那么我已经对url的编码解码过程做了一个分析，要注意的点和需要设置的地方在文中已经提到了。对于网上常见的一个设置：<code>request.setCharacterEncoding(charset)</code>，设不设置都无所谓了，它的作用和contentType是一样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这个实验，是在采用ssm框架的基础上演示的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在前端向后端发出http请求时，有时候当我们采用GET方式时，参数会被编码在url后面。那么这个url是如何编码解码的呢？&lt;/p&gt;
&lt;h2 id=&quot;http请求
      
    
    </summary>
    
    
      <category term="http" scheme="https://blog.ibard.cn/tags/http/"/>
    
      <category term="url编码" scheme="https://blog.ibard.cn/tags/url%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
</feed>
